#include "ros/ros.h"
#include "std_msgs/String.h"
#include "nav_msgs/Odometry.h"
#include "sensor_msgs/PointCloud.h"
#include <visualization_msgs/Marker.h>
#include <geometry_msgs/Twist.h>
#include <visualization_msgs/MarkerArray.h>
#include <Eigen/Eigen>
#include <cmath>
const double PI=3.14159265359;

class potentialField
{
	public:


		potentialField(ros::NodeHandle & n_, double & freq_, double & gain_, double & robot_mass_, double & robot_radius_, std::string & pose_topic_name_, std::string & sonar_topic_name_) : n(n_), freq(freq_), gain(gain_), robot_mass(robot_mass_), robot_radius(robot_radius_), pose_topic_name(pose_topic_name_), sonar_topic_name(sonar_topic_name_)
		{
			visualization_markers_pub = n.advertise<visualization_msgs::MarkerArray>( "force_field", 10);
			velocity_cmd_pub = n.advertise<geometry_msgs::Twist>( "/RosAria/cmd_vel", 2);

			odometry_new_readings=false;
			obstacles_new_readings=false;
			init_flag=false;

  			robot_odometry_sub = n.subscribe(pose_topic_name, 1, &potentialField::odometryCallback, this);
  			obstacle_readings_sub = n.subscribe(sonar_topic_name, 1, &potentialField::sonarCallback, this);		
		};


		void computeForceField()
	  	{
			ROS_INFO("ENTROU");
			// Compute current robot Velocity based on odometry readings
			Eigen::Vector3d current_velocity((current_position.x() - previous_position.x()) * freq, (current_position.y() - previous_position.y()) * freq,0.0);

			boost::shared_ptr<sensor_msgs::PointCloud const> sharedPtr;
			sensor_msgs::PointCloud current_sonar;

			std::vector<double> potential_field;
			Eigen::Matrix3d current_velocity_mat;
			current_velocity_mat << current_velocity.x(), 0, 0, 
						0, current_velocity.y(), 0,
						0, 0, current_velocity.z();

			// for each obstacle compute velocity with respect to that object 
			for(int i=0; i<obstacles_positions.size(); ++i)
			{

				// Compute robot velocity component to the obstacle
				Eigen::Vector3d obstacle_position_normalized=obstacles_positions[i].normalized();
				Eigen::Matrix3d obstacle_position_normalized_mat;
				obstacle_position_normalized_mat << obstacle_position_normalized.x(), 0, 0, 
							 	    0, obstacle_position_normalized.y(), 0,
								    0, 0, obstacle_position_normalized.z();
				Eigen::Matrix3d obstacle_velocity_mat=current_velocity_mat*obstacle_position_normalized_mat;
				Eigen::Vector3d obstacle_velocity(obstacle_velocity_mat(0,0),obstacle_velocity_mat(1,1), obstacle_velocity_mat(2,2));

				double velocity_sign=1.0;
				if(obstacle_velocity.dot(Eigen::Vector3d::UnitX())<0)
					velocity_sign=-1.0; // Moving away from the obstacle

			
				potential_field.push_back(getPotentialPoint(obstacles_positions[i].norm(),velocity_sign*obstacle_velocity.norm(), a_max, gain));	
			}

			if(!init_flag)
			{
				init_flag=true;
				previous_position=current_position;
				previous_potential_field=potential_field;

				odometry_new_readings=false;
				obstacles_new_readings=false;
				return;
			}


			// Get force field
			std::vector<Eigen::Vector3d> force_field;
			for(int i=0; i<potential_field.size(); ++i)
			{
				double force_magnitude=(potential_field[i]-previous_potential_field[i])*freq; // Gradient of the potential field

				//std::cout << "force magnitute:"<< force_magnitude << std::endl;
				force_field.push_back(force_magnitude*(obstacles_positions[i].normalized()));
			}
			
			resulting_force=Eigen::Vector3d(0.0,0.0,0.0);
			for(int i=0; i<force_field.size(); ++i)
			{
				resulting_force+=force_field[i];
			}

			std::cout << resulting_force << std::endl;

			// Publish visual markers to see in rviz
			ROS_INFO("ENTROU2");
			visualization_msgs::MarkerArray marker_array=rviz_arrows(force_field, obstacles_positions, std::string("force_field"));
			visualization_msgs::Marker marker=rviz_arrow(resulting_force, Eigen::Vector3d(0,0,0), 0, std::string("resulting_force"));
			marker_array.markers.push_back(marker);		
			visualization_markers_pub.publish(marker_array);
			
			previous_position=current_position;
			previous_potential_field=potential_field;  

			odometry_new_readings=false;
			obstacles_new_readings=false;
			ROS_INFO("SAIU");
		}

	private:
		// ROS
		ros::NodeHandle n; 

  		ros::Subscriber robot_odometry_sub;
  		ros::Subscriber obstacle_readings_sub;
  		ros::Publisher velocity_cmd_pub;
		ros::Publisher visualization_markers_pub;

		std::string pose_topic_name;
		std::string sonar_topic_name;

		std::string velocity_cmd_topic_name;

		// Parameters
		double a_max;
		double gain;
		double freq; 
		double robot_mass;
		double robot_radius;
		const static double laser_max_distance=5.10;


		// Helper variables
		bool init_flag;
		bool odometry_new_readings;
		bool obstacles_new_readings;

		std::vector<Eigen::Vector3d> obstacles_positions;
		Eigen::Vector3d current_position;
		Eigen::Vector3d previous_position;
		Eigen::Vector3d resulting_force;


		std::vector<double> previous_potential_field;


		visualization_msgs::Marker rviz_arrow(const Eigen::Vector3d & arrow, const Eigen::Vector3d & arrow_origin, int id, std::string name_space ) 
		{
			Eigen::Quaternion<double> rotation;
			if(arrow.norm()<0.0001)
			{
				rotation=Eigen::Quaternion<double>(1,0,0,0);
			}
			else
			{
				double rotation_angle=acos(arrow.normalized().dot(Eigen::Vector3d::UnitX()));
				Eigen::Vector3d rotation_axis=arrow.normalized().cross(Eigen::Vector3d::UnitX()).normalized();
				rotation=Eigen::AngleAxisd(-rotation_angle+PI,rotation_axis);
			}

			
			visualization_msgs::Marker marker;
			marker.header.frame_id = "base_link";
			marker.header.stamp = ros::Time();
			marker.id = id;
			if(id==0)
			{
				marker.color.r = 0.0;
				marker.color.g = 0.0;
				marker.color.b = 1.0;
				marker.ns = name_space;
			}
			else
			{
				marker.color.r = 1.0;
				marker.color.g = 0.0;
				marker.color.b = 0.0;
				marker.ns = name_space;
			}
			marker.type = visualization_msgs::Marker::ARROW;
			marker.action = visualization_msgs::Marker::ADD;
			marker.pose.position.x = arrow_origin.x();
			marker.pose.position.y = arrow_origin.y();
			marker.pose.position.z = arrow_origin.z();
			marker.pose.orientation.x = rotation.x();
			marker.pose.orientation.y = rotation.y();
			marker.pose.orientation.z = rotation.z();
			marker.pose.orientation.w = rotation.w();
			//std::cout <<"position:" <<marker.pose.position << std::endl;
			//std::cout <<"orientation:" <<marker.pose.orientation << std::endl;
			//marker.pose.orientation.x = 0;
			//marker.pose.orientation.y = 0;
			//marker.pose.orientation.z = 0;
			//marker.pose.orientation.w = 1;
			if(arrow.norm()<0.0001)
			{
				marker.scale.x = 0.001;
				marker.scale.y = 0.001;
				marker.scale.z = 0.001;
			}
			else
			{
				marker.scale.x = arrow.norm();
				marker.scale.y = 0.1;
				marker.scale.z = 0.1;
			}
			marker.color.a = 1.0;


			return marker;
		}

		visualization_msgs::MarkerArray rviz_arrows(const std::vector<Eigen::Vector3d> & arrows, const std::vector<Eigen::Vector3d> arrows_origins, std::string name_space)
		{
			visualization_msgs::MarkerArray marker_array;
			for(int i=0; i< arrows.size();++i)
			{
				marker_array.markers.push_back(rviz_arrow(arrows[i], arrows_origins[i], (i+1), name_space));
			}
			return marker_array;
		}

		double getPotentialPoint(const double & d, const double & v_i, const double & a_max, const double & gain)
		{
			float dstop = (v_i*v_i) / (2*a_max ) ;		 
			float dres ; 
			if ( v_i <= 0 ) dres = d + dstop ; 
			else dres = d - dstop ; 

			if ( dres <= 0 || (1+v_i)/dres >= 1/gain)
				return  1.0; 
			else if ( (1+v_i)/dres <= 0) 
				return 0 ;
			else 
				return gain *(1+v_i)/ dres; 
		}

		void odometryCallback(const nav_msgs::Odometry::ConstPtr& msg)
		{
			current_position=Eigen::Vector3d(msg->twist.twist.linear.x, msg->twist.twist.linear.y,0.0);

			odometry_new_readings=true;
  			//ROS_INFO("I heard pose data: [%f, %f , %f]", msg->twist.twist.linear.x, msg->twist.twist.linear.y, msg->twist.twist.linear.z );
			if(obstacles_new_readings==true)
			{
				computeForceField();
				feedbackVelocityControl();
			}
		}

		void sonarCallback(const sensor_msgs::PointCloud::ConstPtr& msg)
		{
			obstacles_positions.clear();
			for(int i=0; i< msg->points.size(); ++i)
			{
				Eigen::Vector3d obstacle(msg->points[i].x,msg->points[i].y,0.0);
				if((obstacle.norm()>robot_radius)&&(obstacle.norm()<laser_max_distance-0.01)) // check if measurement is between the laser range and the robot
				{
					//ROS_INFO_STREAM("INSIDE THE LIMITS:"<<obstacle.norm());
					obstacles_positions.push_back(obstacle);
				}
				//else
				//{
				//	ROS_INFO_STREAM("OUTSIDE THE LIMITS:"<<obstacle.norm());
				//}

			}
			//ROS_INFO_STREAM("obstacles:" << obstacles_positions.size());
		 	//ROS_INFO("I heard sensor data : [%f, %f , %f]", msg->points[0].x , msg->points[0].y , msg->points[0].z  );
			obstacles_new_readings=true;
	
			if(odometry_new_readings==true)
			{
				computeForceField();
				feedbackVelocityControl();
			}	
		}

		void feedbackVelocityControl()
		{
			// Compute linear velocity (x velocity)
			double linear_speed=resulting_force.x()/(freq*robot_mass); // LINEAR SPEED IS GIVEN BY THE PROJECTION OF THE FORCE IN X (normal component)

			double angular_speed=(resulting_force.y()/(robot_mass*robot_radius))*freq; // ROTATIONAL SPEED IS GIVEN BY THE PROJECTION OF THE FORCE IN Y (perpendicular component)
			geometry_msgs::Twist twist_msg;
			twist_msg.linear.x=linear_speed;
			twist_msg.angular.z=angular_speed;
			std::cout << "velocities"<<twist_msg << std::endl;
			velocity_cmd_pub.publish(twist_msg);
			
		}
};

int main(int argc, char **argv)
{
	/**
	   * The ros::init() function needs to see argc and argv so that it can perform
	   * any ROS arguments and name remapping that were provided at the command line. For programmatic
	   * remappings you can use a different version of init() which takes remappings
	   * directly, but for most command-line programs, passing argc and argv is the easiest
	   * way to do it.  The third argument to init() is the name of the node.
	   *
	   * You must call one of the versions of ros::init() before using any other
	   * part of the ROS system.
	*/
  	ros::init(argc, argv, "potential_field");
	/**
   	* NodeHandle is the main access point to communications with the ROS system.
   	* The first NodeHandle constructed will fully initialize this node, and the last
   	* NodeHandle destructed will close down the node.
   	*/
  	ros::NodeHandle n;

  	ros::NodeHandle n_priv("~");

	// parameters
	double a_max;
	double gain;
	double freq; 
	double robot_mass; 
	double robot_radius; 

	//initialize operational parameters
    	n_priv.param<double>("frequency", freq, 10.0);
    	n_priv.param<double>("gain", gain, 1.0);
    	n_priv.param<double>("acc_max", a_max, 1.0);
    	n_priv.param<double>("robot_mass", robot_mass, 1.0);
    	n_priv.param<double>("robot_radius", robot_radius, 0.2);

	ros::Rate loop_rate(freq); 

	std::string pose_topic_name = "/RosAria/pose" ;
  	std::string sonar_topic_name = "/RosAria/sonar"; 

	potentialField potential_field(n, freq, gain, robot_mass, robot_radius, pose_topic_name, sonar_topic_name);
	ros::spin();
 	return 0;
}
